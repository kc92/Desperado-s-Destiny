/**
 * Anti-Exploit Middleware
 *
 * Prevents gold duplication, XP farming loops, and other exploits.
 * Monitors transactions and flags suspicious activity.
 */

import { Request, Response, NextFunction } from 'express';
import { AuthRequest } from './requireAuth';
import { Character } from '../models/Character.model';
import { GoldTransaction, TransactionSource } from '../models/GoldTransaction.model';
import { EXPLOIT_THRESHOLDS } from '../config/economy.config';
import { BalanceValidationService } from '../services/balanceValidation.service';
import logger from '../utils/logger';
import { createClient, RedisClientType } from 'redis';
import { config } from '../config';

// Redis client for rate limiting
let redis: RedisClientType | null = null;

(async () => {
  try {
    redis = createClient({
      url: config.database.redisUrl,
      password: config.database.redisPassword,
    });
    await redis.connect();
  } catch (error) {
    logger.warn('Redis not available for anti-exploit middleware. Using in-memory fallback.');
  }
})();

/**
 * In-memory rate limit cache (fallback if Redis unavailable)
 */
const rateLimitCache = new Map<string, { count: number; resetAt: number }>();

/**
 * Anti-exploit middleware configuration
 */
export interface AntiExploitConfig {
  enableGoldDuplicationCheck: boolean;
  enableRateLimiting: boolean;
  enableSuspiciousPatternDetection: boolean;
  autoBlockSuspicious: boolean;
  logAllTransactions: boolean;
}

const DEFAULT_CONFIG: AntiExploitConfig = {
  enableGoldDuplicationCheck: true,
  enableRateLimiting: true,
  enableSuspiciousPatternDetection: true,
  autoBlockSuspicious: false, // Don't auto-block, just flag
  logAllTransactions: process.env.NODE_ENV === 'production'
};

/**
 * Check for gold duplication exploits
 */
export function checkGoldDuplication(config: AntiExploitConfig = DEFAULT_CONFIG) {
  return async (req: AuthRequest, res: Response, next: NextFunction): Promise<void> => {
    if (!config.enableGoldDuplicationCheck) {
      return next();
    }

    try {
      const characterId = req.character?._id?.toString();
      if (!characterId) {
        return next();
      }

      // Check for duplication in last 5 minutes
      const isDuplicated = await BalanceValidationService.detectGoldDuplication(characterId, 5);

      if (isDuplicated) {
        logger.error(`EXPLOIT DETECTED: Gold duplication for character ${characterId}`, {
          characterId,
          userId: req.user?._id,
          endpoint: req.path,
          method: req.method
        });

        if (config.autoBlockSuspicious) {
          res.status(403).json({
            error: 'Suspicious activity detected',
            message: 'This account has been flagged for review'
          });
          return;
        }
      }

      next();
    } catch (error) {
      logger.error('Error in gold duplication check:', error);
      next(); // Don't block on error
    }
  };
}

/**
 * Rate limit gold transactions
 */
export function rateLimitGoldTransactions(
  maxTransactionsPerHour: number = 100,
  config: AntiExploitConfig = DEFAULT_CONFIG
) {
  return async (req: AuthRequest, res: Response, next: NextFunction): Promise<void> => {
    if (!config.enableRateLimiting) {
      return next();
    }

    try {
      const characterId = req.character?._id?.toString();
      if (!characterId) {
        return next();
      }

      const key = `gold_tx_limit:${characterId}`;
      const now = Date.now();
      const windowMs = 60 * 60 * 1000; // 1 hour

      let count: number;

      if (redis) {
        // Use Redis for distributed rate limiting
        const current = await redis.get(key);

        if (current) {
          count = parseInt(current, 10) + 1;
          await redis.set(key, count.toString(), { PX: windowMs } as any);
        } else {
          count = 1;
          await redis.set(key, '1', { PX: windowMs } as any);
        }
      } else {
        // Fallback to in-memory cache
        const cached = rateLimitCache.get(key);

        if (cached && cached.resetAt > now) {
          count = cached.count + 1;
          rateLimitCache.set(key, { count, resetAt: cached.resetAt });
        } else {
          count = 1;
          rateLimitCache.set(key, { count, resetAt: now + windowMs });
        }
      }

      if (count > maxTransactionsPerHour) {
        logger.warn(`Rate limit exceeded for character ${characterId}`, {
          characterId,
          count,
          limit: maxTransactionsPerHour
        });

        res.status(429).json({
          error: 'Rate limit exceeded',
          message: 'Too many transactions. Please try again later.',
          retryAfter: 3600 // 1 hour
        });
        return;
      }

      next();
    } catch (error) {
      logger.error('Error in rate limiting:', error);
      next(); // Don't block on error
    }
  };
}

/**
 * Detect suspicious earning patterns
 */
export function detectSuspiciousEarning(config: AntiExploitConfig = DEFAULT_CONFIG) {
  return async (req: AuthRequest, res: Response, next: NextFunction): Promise<void> => {
    if (!config.enableSuspiciousPatternDetection) {
      return next();
    }

    try {
      const characterId = req.character?._id?.toString();
      if (!characterId) {
        return next();
      }

      // Check earning rate
      const earningCheck = await BalanceValidationService.isEarningRateSuspicious(characterId);

      if (earningCheck.suspicious) {
        logger.warn(`Suspicious earning rate detected for character ${characterId}`, {
          characterId,
          goldPerHour: earningCheck.goldPerHour,
          expectedMax: earningCheck.expectedMax
        });

        if (config.autoBlockSuspicious) {
          res.status(403).json({
            error: 'Suspicious activity detected',
            message: 'Earning rate exceeds normal limits'
          });
          return;
        }
      }

      next();
    } catch (error) {
      logger.error('Error in suspicious earning detection:', error);
      next(); // Don't block on error
    }
  };
}

/**
 * Prevent XP farming exploits
 */
export function preventXPFarming(
  maxXPPerHour: number = EXPLOIT_THRESHOLDS.maxXPPerHour,
  config: AntiExploitConfig = DEFAULT_CONFIG
) {
  return async (req: AuthRequest, res: Response, next: NextFunction): Promise<void> => {
    if (!config.enableSuspiciousPatternDetection) {
      return next();
    }

    try {
      const characterId = req.character?._id?.toString();
      if (!characterId) {
        return next();
      }

      const key = `xp_farming:${characterId}`;
      const now = Date.now();
      const oneHourAgo = now - (60 * 60 * 1000);

      // Get character's recent XP gains
      const character = await Character.findById(characterId).select('experience updatedAt');
      if (!character) {
        return next();
      }

      let xpGained = 0;

      if (redis) {
        const cached = await redis.get(key);
        if (cached) {
          xpGained = parseInt(cached, 10);
        }
      }

      if (xpGained > maxXPPerHour) {
        logger.warn(`Potential XP farming detected for character ${characterId}`, {
          characterId,
          xpGained,
          maxAllowed: maxXPPerHour
        });

        if (config.autoBlockSuspicious) {
          res.status(429).json({
            error: 'XP rate limit exceeded',
            message: 'Take a break and come back later'
          });
          return;
        }
      }

      next();
    } catch (error) {
      logger.error('Error in XP farming prevention:', error);
      next(); // Don't block on error
    }
  };
}

/**
 * Prevent item duplication exploits
 */
export function preventItemDuplication(config: AntiExploitConfig = DEFAULT_CONFIG) {
  return async (req: AuthRequest, res: Response, next: NextFunction): Promise<void> => {
    if (!config.enableSuspiciousPatternDetection) {
      return next();
    }

    try {
      const characterId = req.character?._id?.toString();
      if (!characterId) {
        return next();
      }

      // Check for suspicious item crafting/selling patterns
      const now = new Date();
      const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);

      // Check if same item crafted excessively
      const recentCrafting = await GoldTransaction.aggregate([
        {
          $match: {
            characterId,
            timestamp: { $gte: oneHourAgo },
            source: TransactionSource.SHOP_SALE,
            'metadata.itemId': { $exists: true }
          }
        },
        {
          $group: {
            _id: '$metadata.itemId',
            count: { $sum: 1 }
          }
        },
        {
          $match: {
            count: { $gt: EXPLOIT_THRESHOLDS.maxSameItemSold }
          }
        }
      ]);

      if (recentCrafting.length > 0) {
        logger.warn(`Potential item duplication detected for character ${characterId}`, {
          characterId,
          items: recentCrafting
        });

        if (config.autoBlockSuspicious) {
          res.status(403).json({
            error: 'Suspicious activity detected',
            message: 'Excessive item selling detected'
          });
          return;
        }
      }

      next();
    } catch (error) {
      logger.error('Error in item duplication prevention:', error);
      next(); // Don't block on error
    }
  };
}

/**
 * Prevent trading exploits
 */
export function preventTradingExploits(
  maxTradesPerHour: number = EXPLOIT_THRESHOLDS.maxTradesPerHour,
  config: AntiExploitConfig = DEFAULT_CONFIG
) {
  return async (req: AuthRequest, res: Response, next: NextFunction): Promise<void> => {
    if (!config.enableRateLimiting) {
      return next();
    }

    try {
      const characterId = req.character?._id?.toString();
      if (!characterId) {
        return next();
      }

      const key = `trade_limit:${characterId}`;
      const now = Date.now();
      const windowMs = 60 * 60 * 1000; // 1 hour

      let tradeCount: number;

      if (redis) {
        const current = await redis.get(key);

        if (current) {
          tradeCount = parseInt(current, 10) + 1;
          await redis.set(key, tradeCount.toString(), { PX: windowMs } as any);
        } else {
          tradeCount = 1;
          await redis.set(key, '1', { PX: windowMs } as any);
        }
      } else {
        const cached = rateLimitCache.get(key);

        if (cached && cached.resetAt > now) {
          tradeCount = cached.count + 1;
          rateLimitCache.set(key, { count: tradeCount, resetAt: cached.resetAt });
        } else {
          tradeCount = 1;
          rateLimitCache.set(key, { count: tradeCount, resetAt: now + windowMs });
        }
      }

      if (tradeCount > maxTradesPerHour) {
        logger.warn(`Trade rate limit exceeded for character ${characterId}`, {
          characterId,
          tradeCount,
          limit: maxTradesPerHour
        });

        res.status(429).json({
          error: 'Trade limit exceeded',
          message: 'Too many trades. Please try again later.',
          retryAfter: 3600
        });
        return;
      }

      next();
    } catch (error) {
      logger.error('Error in trading exploit prevention:', error);
      next(); // Don't block on error
    }
  };
}

/**
 * Log all economic transactions (for audit trail)
 */
export function logEconomicTransaction(config: AntiExploitConfig = DEFAULT_CONFIG) {
  return (req: AuthRequest, res: Response, next: NextFunction): void => {
    if (!config.logAllTransactions) {
      return next();
    }

    // Log the request
    const logData = {
      timestamp: new Date(),
      characterId: req.character?._id?.toString(),
      userId: req.user?._id?.toString(),
      endpoint: req.path,
      method: req.method,
      body: req.body,
      ip: req.ip
    };

    logger.info('Economic transaction logged', logData);

    next();
  };
}

/**
 * Composite middleware: Full anti-exploit protection
 */
export function fullAntiExploitProtection(config: AntiExploitConfig = DEFAULT_CONFIG) {
  return [
    checkGoldDuplication(config),
    rateLimitGoldTransactions(100, config),
    detectSuspiciousEarning(config),
    preventXPFarming(EXPLOIT_THRESHOLDS.maxXPPerHour, config),
    preventItemDuplication(config),
    preventTradingExploits(EXPLOIT_THRESHOLDS.maxTradesPerHour, config),
    logEconomicTransaction(config)
  ];
}

/**
 * Cleanup function for in-memory cache
 */
export function cleanupRateLimitCache(): void {
  const now = Date.now();

  for (const [key, value] of rateLimitCache.entries()) {
    if (value.resetAt <= now) {
      rateLimitCache.delete(key);
    }
  }
}

// Run cleanup every 5 minutes
setInterval(cleanupRateLimitCache, 5 * 60 * 1000);

export default {
  checkGoldDuplication,
  rateLimitGoldTransactions,
  detectSuspiciousEarning,
  preventXPFarming,
  preventItemDuplication,
  preventTradingExploits,
  logEconomicTransaction,
  fullAntiExploitProtection,
  cleanupRateLimitCache
};
