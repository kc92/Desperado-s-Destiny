/**
 * ExploitTracker.ts - Dashboard for tracking and managing security exploits
 *
 * Provides comprehensive tracking of exploits found by AdversarialBot,
 * including classification, reproduction steps, fix tracking, and reporting.
 */

import * as fs from 'fs';
import * as path from 'path';

// ============================================================================
// INTERFACES
// ============================================================================

/**
 * Detailed exploit report
 */
export interface ExploitReport {
  // Identification
  id: string;
  title: string;
  description: string;

  // Classification
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  category: string;
  cwe?: string; // Common Weakness Enumeration ID
  cvss?: number; // Common Vulnerability Scoring System (0-10)

  // Discovery
  discoveredBy: string; // Bot ID
  discoveredAt: Date;
  testSuite?: string;

  // Technical details
  affectedEndpoints: string[];
  affectedComponents: string[];
  reproductionSteps: string[];
  actualBehavior: string;
  expectedBehavior: string;

  // Impact
  impact: string;
  exploitability: 'easy' | 'medium' | 'hard';
  prerequisites: string[];

  // Evidence
  evidence: {
    screenshots?: string[];
    logs?: string[];
    networkRequests?: any[];
    payloads?: string[];
  };

  // Remediation
  recommendation: string;
  fixStatus: 'new' | 'acknowledged' | 'in-progress' | 'fixed' | 'wont-fix' | 'duplicate';
  fixedBy?: string;
  fixedAt?: Date;
  fixCommit?: string;

  // Related
  duplicateOf?: string;
  relatedExploits?: string[];
  tags: string[];
}

/**
 * Exploit statistics
 */
export interface ExploitStatistics {
  total: number;
  byStatus: Record<ExploitReport['fixStatus'], number>;
  bySeverity: Record<ExploitReport['severity'], number>;
  byCategory: Record<string, number>;
  avgTimeToFix: number; // milliseconds
  fixRate: number; // percentage
}

/**
 * Exploit filter
 */
export interface ExploitFilter {
  severity?: ExploitReport['severity'][];
  status?: ExploitReport['fixStatus'][];
  category?: string[];
  discoveredBy?: string[];
  tags?: string[];
  dateRange?: {
    from: Date;
    to: Date;
  };
}

// ============================================================================
// EXPLOIT TRACKER CLASS
// ============================================================================

/**
 * Tracks and manages security exploits
 */
export class ExploitTracker {
  private exploits: Map<string, ExploitReport> = new Map();
  private dataDir: string;
  private autoExportEnabled: boolean = true;

  constructor(dataDir: string = './tests/playtests/exploits') {
    this.dataDir = dataDir;
    this.ensureDataDirectory();
    this.loadExistingExploits();
  }

  /**
   * Ensure data directory exists
   */
  private ensureDataDirectory(): void {
    if (!fs.existsSync(this.dataDir)) {
      fs.mkdirSync(this.dataDir, { recursive: true });
    }
  }

  /**
   * Load existing exploits from disk
   */
  private loadExistingExploits(): void {
    try {
      const files = fs.readdirSync(this.dataDir);
      const jsonFiles = files.filter(f => f.endsWith('.json'));

      for (const file of jsonFiles) {
        try {
          const data = fs.readFileSync(path.join(this.dataDir, file), 'utf-8');
          const exploit = JSON.parse(data) as ExploitReport;

          // Convert date strings to Date objects
          exploit.discoveredAt = new Date(exploit.discoveredAt);
          if (exploit.fixedAt) {
            exploit.fixedAt = new Date(exploit.fixedAt);
          }

          this.exploits.set(exploit.id, exploit);
        } catch (error) {
          console.error(`[ExploitTracker] Error loading ${file}:`, error);
        }
      }

      console.log(`[ExploitTracker] Loaded ${this.exploits.size} existing exploits`);
    } catch (error) {
      console.log('[ExploitTracker] No existing exploits found');
    }
  }

  // ============================================================================
  // EXPLOIT MANAGEMENT
  // ============================================================================

  /**
   * Record a new exploit
   */
  recordExploit(data: Omit<ExploitReport, 'id' | 'discoveredAt' | 'fixStatus'>): ExploitReport {
    const id = `EXPLOIT-${Date.now()}-${Math.random().toString(36).substr(2, 9).toUpperCase()}`;

    const exploit: ExploitReport = {
      ...data,
      id,
      discoveredAt: new Date(),
      fixStatus: 'new',
      tags: data.tags || [],
    };

    // Calculate CVSS if not provided
    if (!exploit.cvss) {
      exploit.cvss = this.calculateCVSS(exploit);
    }

    this.exploits.set(id, exploit);

    // Auto-export
    if (this.autoExportEnabled) {
      this.exportExploit(id);
    }

    console.log(`[ExploitTracker] New ${exploit.severity} exploit: ${exploit.title} (${id})`);

    return exploit;
  }

  /**
   * Update exploit status
   */
  updateExploitStatus(
    exploitId: string,
    status: ExploitReport['fixStatus'],
    metadata?: {
      fixedBy?: string;
      fixCommit?: string;
    }
  ): boolean {
    const exploit = this.exploits.get(exploitId);
    if (!exploit) {
      console.error(`[ExploitTracker] Exploit not found: ${exploitId}`);
      return false;
    }

    exploit.fixStatus = status;

    if (status === 'fixed') {
      exploit.fixedAt = new Date();
      if (metadata?.fixedBy) {
        exploit.fixedBy = metadata.fixedBy;
      }
      if (metadata?.fixCommit) {
        exploit.fixCommit = metadata.fixCommit;
      }
    }

    if (this.autoExportEnabled) {
      this.exportExploit(exploitId);
    }

    console.log(`[ExploitTracker] Updated ${exploitId} status: ${status}`);
    return true;
  }

  /**
   * Mark exploit as duplicate
   */
  markAsDuplicate(exploitId: string, duplicateOf: string): boolean {
    const exploit = this.exploits.get(exploitId);
    const original = this.exploits.get(duplicateOf);

    if (!exploit || !original) {
      return false;
    }

    exploit.fixStatus = 'duplicate';
    exploit.duplicateOf = duplicateOf;

    // Add to original's related exploits
    if (!original.relatedExploits) {
      original.relatedExploits = [];
    }
    if (!original.relatedExploits.includes(exploitId)) {
      original.relatedExploits.push(exploitId);
    }

    if (this.autoExportEnabled) {
      this.exportExploit(exploitId);
      this.exportExploit(duplicateOf);
    }

    return true;
  }

  /**
   * Add tag to exploit
   */
  addTag(exploitId: string, tag: string): boolean {
    const exploit = this.exploits.get(exploitId);
    if (!exploit) return false;

    if (!exploit.tags.includes(tag)) {
      exploit.tags.push(tag);

      if (this.autoExportEnabled) {
        this.exportExploit(exploitId);
      }
    }

    return true;
  }

  /**
   * Link related exploits
   */
  linkExploits(exploitId1: string, exploitId2: string): boolean {
    const exploit1 = this.exploits.get(exploitId1);
    const exploit2 = this.exploits.get(exploitId2);

    if (!exploit1 || !exploit2) return false;

    if (!exploit1.relatedExploits) exploit1.relatedExploits = [];
    if (!exploit2.relatedExploits) exploit2.relatedExploits = [];

    if (!exploit1.relatedExploits.includes(exploitId2)) {
      exploit1.relatedExploits.push(exploitId2);
    }

    if (!exploit2.relatedExploits.includes(exploitId1)) {
      exploit2.relatedExploits.push(exploitId1);
    }

    return true;
  }

  // ============================================================================
  // QUERYING & FILTERING
  // ============================================================================

  /**
   * Get exploit by ID
   */
  getExploit(exploitId: string): ExploitReport | null {
    return this.exploits.get(exploitId) || null;
  }

  /**
   * Get all exploits
   */
  getAllExploits(): ExploitReport[] {
    return Array.from(this.exploits.values());
  }

  /**
   * Filter exploits
   */
  filterExploits(filter: ExploitFilter): ExploitReport[] {
    let filtered = Array.from(this.exploits.values());

    if (filter.severity) {
      filtered = filtered.filter(e => filter.severity!.includes(e.severity));
    }

    if (filter.status) {
      filtered = filtered.filter(e => filter.status!.includes(e.fixStatus));
    }

    if (filter.category) {
      filtered = filtered.filter(e => filter.category!.includes(e.category));
    }

    if (filter.discoveredBy) {
      filtered = filtered.filter(e => filter.discoveredBy!.includes(e.discoveredBy));
    }

    if (filter.tags && filter.tags.length > 0) {
      filtered = filtered.filter(e => filter.tags!.some(tag => e.tags.includes(tag)));
    }

    if (filter.dateRange) {
      filtered = filtered.filter(
        e =>
          e.discoveredAt >= filter.dateRange!.from &&
          e.discoveredAt <= filter.dateRange!.to
      );
    }

    return filtered;
  }

  /**
   * Search exploits by keyword
   */
  searchExploits(query: string): ExploitReport[] {
    const lowerQuery = query.toLowerCase();

    return Array.from(this.exploits.values()).filter(
      e =>
        e.title.toLowerCase().includes(lowerQuery) ||
        e.description.toLowerCase().includes(lowerQuery) ||
        e.category.toLowerCase().includes(lowerQuery) ||
        e.tags.some(tag => tag.toLowerCase().includes(lowerQuery))
    );
  }

  /**
   * Get active (unfixed) exploits
   */
  getActiveExploits(): ExploitReport[] {
    return Array.from(this.exploits.values()).filter(
      e => !['fixed', 'wont-fix', 'duplicate'].includes(e.fixStatus)
    );
  }

  /**
   * Get critical exploits
   */
  getCriticalExploits(): ExploitReport[] {
    return Array.from(this.exploits.values()).filter(
      e => e.severity === 'CRITICAL' && e.fixStatus === 'new'
    );
  }

  // ============================================================================
  // STATISTICS & ANALYTICS
  // ============================================================================

  /**
   * Get exploit statistics
   */
  getStatistics(): ExploitStatistics {
    const exploits = Array.from(this.exploits.values());

    const byStatus: Record<ExploitReport['fixStatus'], number> = {
      new: 0,
      acknowledged: 0,
      'in-progress': 0,
      fixed: 0,
      'wont-fix': 0,
      duplicate: 0,
    };

    const bySeverity: Record<ExploitReport['severity'], number> = {
      CRITICAL: 0,
      HIGH: 0,
      MEDIUM: 0,
      LOW: 0,
    };

    const byCategory: Record<string, number> = {};

    let totalTimeToFix = 0;
    let fixedCount = 0;

    for (const exploit of exploits) {
      byStatus[exploit.fixStatus]++;
      bySeverity[exploit.severity]++;

      byCategory[exploit.category] = (byCategory[exploit.category] || 0) + 1;

      if (exploit.fixStatus === 'fixed' && exploit.fixedAt) {
        const timeToFix = exploit.fixedAt.getTime() - exploit.discoveredAt.getTime();
        totalTimeToFix += timeToFix;
        fixedCount++;
      }
    }

    const avgTimeToFix = fixedCount > 0 ? totalTimeToFix / fixedCount : 0;
    const fixRate = exploits.length > 0 ? (byStatus.fixed / exploits.length) * 100 : 0;

    return {
      total: exploits.length,
      byStatus,
      bySeverity,
      byCategory,
      avgTimeToFix,
      fixRate,
    };
  }

  /**
   * Get top categories by exploit count
   */
  getTopCategories(count: number = 10): Array<{ category: string; count: number }> {
    const stats = this.getStatistics();

    return Object.entries(stats.byCategory)
      .map(([category, count]) => ({ category, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, count);
  }

  /**
   * Get exploits by bot
   */
  getExploitsByBot(botId: string): ExploitReport[] {
    return Array.from(this.exploits.values()).filter(e => e.discoveredBy === botId);
  }

  // ============================================================================
  // CVSS CALCULATION
  // ============================================================================

  /**
   * Calculate CVSS score (simplified)
   * Real CVSS is more complex - this is an approximation
   */
  private calculateCVSS(exploit: ExploitReport): number {
    let score = 0;

    // Base severity
    const severityScores = {
      CRITICAL: 9.0,
      HIGH: 7.0,
      MEDIUM: 5.0,
      LOW: 3.0,
    };
    score = severityScores[exploit.severity];

    // Adjust for exploitability
    if (exploit.exploitability === 'easy') {
      score += 1.0;
    } else if (exploit.exploitability === 'hard') {
      score -= 0.5;
    }

    // Adjust for prerequisites
    if (exploit.prerequisites && exploit.prerequisites.length > 2) {
      score -= 0.5;
    }

    // Cap at 10
    return Math.min(10, Math.max(0, score));
  }

  // ============================================================================
  // REPRODUCTION
  // ============================================================================

  /**
   * Generate reproduction script
   */
  generateReproductionScript(exploitId: string): string {
    const exploit = this.exploits.get(exploitId);
    if (!exploit) return '';

    const lines = [
      '/**',
      ` * Reproduction script for: ${exploit.title}`,
      ` * Exploit ID: ${exploit.id}`,
      ` * Severity: ${exploit.severity}`,
      ' */',
      '',
      'import { Page } from \'puppeteer\';',
      '',
      `async function reproduce_${exploit.id}(page: Page) {`,
      '  console.log(\'Attempting to reproduce exploit...\');',
      '',
    ];

    // Add reproduction steps as comments and pseudocode
    exploit.reproductionSteps.forEach((step, i) => {
      lines.push(`  // Step ${i + 1}: ${step}`);
      lines.push('  // TODO: Implement this step');
      lines.push('');
    });

    lines.push('  console.log(\'Exploit reproduction complete\');');
    lines.push('}');
    lines.push('');
    lines.push(`export default reproduce_${exploit.id};`);

    return lines.join('\n');
  }

  // ============================================================================
  // REPORTING
  // ============================================================================

  /**
   * Generate summary report
   */
  generateSummaryReport(): string {
    const stats = this.getStatistics();
    const critical = this.getCriticalExploits();
    const active = this.getActiveExploits();

    const lines = [
      '='.repeat(80),
      'EXPLOIT TRACKER SUMMARY REPORT',
      '='.repeat(80),
      '',
      'Overall Statistics:',
      `  Total Exploits: ${stats.total}`,
      `  Active (Unfixed): ${active.length}`,
      `  Fixed: ${stats.byStatus.fixed}`,
      `  Fix Rate: ${stats.fixRate.toFixed(1)}%`,
      `  Avg Time to Fix: ${(stats.avgTimeToFix / (1000 * 60 * 60)).toFixed(1)} hours`,
      '',
      'By Severity:',
      `  CRITICAL: ${stats.bySeverity.CRITICAL} (${critical.length} active)`,
      `  HIGH:     ${stats.bySeverity.HIGH}`,
      `  MEDIUM:   ${stats.bySeverity.MEDIUM}`,
      `  LOW:      ${stats.bySeverity.LOW}`,
      '',
      'By Status:',
      `  New:          ${stats.byStatus.new}`,
      `  Acknowledged: ${stats.byStatus.acknowledged}`,
      `  In Progress:  ${stats.byStatus['in-progress']}`,
      `  Fixed:        ${stats.byStatus.fixed}`,
      `  Won't Fix:    ${stats.byStatus['wont-fix']}`,
      `  Duplicate:    ${stats.byStatus.duplicate}`,
      '',
    ];

    // Top categories
    const topCategories = this.getTopCategories(5);
    if (topCategories.length > 0) {
      lines.push('Top Categories:');
      topCategories.forEach(({ category, count }) => {
        lines.push(`  ${category}: ${count}`);
      });
      lines.push('');
    }

    // Critical exploits
    if (critical.length > 0) {
      lines.push('CRITICAL EXPLOITS REQUIRING IMMEDIATE ATTENTION:');
      critical.forEach(exploit => {
        lines.push(`  [${exploit.id}] ${exploit.title}`);
        lines.push(`    Category: ${exploit.category}`);
        lines.push(`    Discovered: ${exploit.discoveredAt.toISOString()}`);
        lines.push('');
      });
    }

    lines.push('='.repeat(80));

    return lines.join('\n');
  }

  /**
   * Generate detailed report for an exploit
   */
  generateDetailedReport(exploitId: string): string {
    const exploit = this.exploits.get(exploitId);
    if (!exploit) {
      return `Exploit not found: ${exploitId}`;
    }

    const lines = [
      '='.repeat(80),
      `EXPLOIT REPORT: ${exploit.id}`,
      '='.repeat(80),
      '',
      `Title: ${exploit.title}`,
      `Severity: ${exploit.severity} (CVSS: ${exploit.cvss?.toFixed(1)})`,
      `Category: ${exploit.category}`,
      `Status: ${exploit.fixStatus}`,
      `Discovered By: ${exploit.discoveredBy}`,
      `Discovered At: ${exploit.discoveredAt.toISOString()}`,
      '',
      'Description:',
      `  ${exploit.description}`,
      '',
      'Reproduction Steps:',
    ];

    exploit.reproductionSteps.forEach((step, i) => {
      lines.push(`  ${i + 1}. ${step}`);
    });

    lines.push('');
    lines.push('Expected Behavior:');
    lines.push(`  ${exploit.expectedBehavior}`);
    lines.push('');
    lines.push('Actual Behavior:');
    lines.push(`  ${exploit.actualBehavior}`);
    lines.push('');
    lines.push('Impact:');
    lines.push(`  ${exploit.impact}`);
    lines.push('');
    lines.push('Recommendation:');
    lines.push(`  ${exploit.recommendation}`);
    lines.push('');

    if (exploit.affectedEndpoints.length > 0) {
      lines.push('Affected Endpoints:');
      exploit.affectedEndpoints.forEach(ep => lines.push(`  - ${ep}`));
      lines.push('');
    }

    if (exploit.tags.length > 0) {
      lines.push(`Tags: ${exploit.tags.join(', ')}`);
      lines.push('');
    }

    if (exploit.fixStatus === 'fixed') {
      lines.push('Fix Details:');
      lines.push(`  Fixed By: ${exploit.fixedBy}`);
      lines.push(`  Fixed At: ${exploit.fixedAt?.toISOString()}`);
      if (exploit.fixCommit) {
        lines.push(`  Commit: ${exploit.fixCommit}`);
      }
      lines.push('');
    }

    lines.push('='.repeat(80));

    return lines.join('\n');
  }

  // ============================================================================
  // EXPORT & IMPORT
  // ============================================================================

  /**
   * Export single exploit to file
   */
  exportExploit(exploitId: string): string | null {
    const exploit = this.exploits.get(exploitId);
    if (!exploit) return null;

    const filename = path.join(this.dataDir, `${exploitId}.json`);
    fs.writeFileSync(filename, JSON.stringify(exploit, null, 2));

    return filename;
  }

  /**
   * Export all exploits to JSON
   */
  exportAllExploits(): string {
    const data = {
      exportedAt: new Date().toISOString(),
      exploits: Array.from(this.exploits.values()),
      statistics: this.getStatistics(),
    };

    const filename = path.join(
      this.dataDir,
      `all-exploits-${new Date().toISOString().replace(/[:.]/g, '-')}.json`
    );

    fs.writeFileSync(filename, JSON.stringify(data, null, 2));

    console.log(`[ExploitTracker] Exported ${this.exploits.size} exploits to ${filename}`);
    return filename;
  }

  /**
   * Export exploits to CSV
   */
  exportToCSV(): string {
    const exploits = Array.from(this.exploits.values());

    const headers = [
      'ID',
      'Title',
      'Severity',
      'Category',
      'Status',
      'CVSS',
      'Discovered By',
      'Discovered At',
      'Fixed At',
      'Impact',
    ];

    const rows = exploits.map(e => [
      e.id,
      `"${e.title}"`,
      e.severity,
      e.category,
      e.fixStatus,
      e.cvss?.toFixed(1) || '',
      e.discoveredBy,
      e.discoveredAt.toISOString(),
      e.fixedAt?.toISOString() || '',
      `"${e.impact}"`,
    ]);

    const csv = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');

    const filename = path.join(
      this.dataDir,
      `exploits-${new Date().toISOString().replace(/[:.]/g, '-')}.csv`
    );

    fs.writeFileSync(filename, csv);

    console.log(`[ExploitTracker] Exported CSV: ${filename}`);
    return filename;
  }

  /**
   * Export exploits to HTML report
   */
  exportToHTML(): string {
    const stats = this.getStatistics();
    const exploits = Array.from(this.exploits.values()).sort(
      (a, b) => b.discoveredAt.getTime() - a.discoveredAt.getTime()
    );

    const severityColors = {
      CRITICAL: '#dc2626',
      HIGH: '#ea580c',
      MEDIUM: '#f59e0b',
      LOW: '#84cc16',
    };

    const statusColors = {
      new: '#3b82f6',
      acknowledged: '#8b5cf6',
      'in-progress': '#f59e0b',
      fixed: '#10b981',
      'wont-fix': '#6b7280',
      duplicate: '#94a3b8',
    };

    const html = `
<!DOCTYPE html>
<html>
<head>
  <title>Exploit Tracker Report</title>
  <style>
    body { font-family: system-ui, -apple-system, sans-serif; padding: 20px; background: #f9fafb; }
    .container { max-width: 1200px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    h1 { color: #111827; border-bottom: 2px solid #e5e7eb; padding-bottom: 10px; }
    .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 30px 0; }
    .stat-card { background: #f3f4f6; padding: 20px; border-radius: 6px; }
    .stat-card h3 { margin: 0 0 10px 0; color: #6b7280; font-size: 14px; }
    .stat-card .value { font-size: 32px; font-weight: bold; color: #111827; }
    table { width: 100%; border-collapse: collapse; margin-top: 30px; }
    th, td { padding: 12px; text-align: left; border-bottom: 1px solid #e5e7eb; }
    th { background: #f9fafb; font-weight: 600; color: #374151; }
    tr:hover { background: #f9fafb; }
    .severity-badge, .status-badge { display: inline-block; padding: 4px 12px; border-radius: 12px; font-size: 12px; font-weight: 600; }
    .severity-CRITICAL { background: #fee2e2; color: #991b1b; }
    .severity-HIGH { background: #ffedd5; color: #9a3412; }
    .severity-MEDIUM { background: #fef3c7; color: #92400e; }
    .severity-LOW { background: #ecfccb; color: #365314; }
    .footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; color: #6b7280; font-size: 14px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Exploit Tracker Report</h1>
    <p>Generated: ${new Date().toISOString()}</p>

    <div class="stats">
      <div class="stat-card">
        <h3>Total Exploits</h3>
        <div class="value">${stats.total}</div>
      </div>
      <div class="stat-card">
        <h3>Critical</h3>
        <div class="value" style="color: #dc2626;">${stats.bySeverity.CRITICAL}</div>
      </div>
      <div class="stat-card">
        <h3>Fixed</h3>
        <div class="value" style="color: #10b981;">${stats.byStatus.fixed}</div>
      </div>
      <div class="stat-card">
        <h3>Fix Rate</h3>
        <div class="value">${stats.fixRate.toFixed(0)}%</div>
      </div>
    </div>

    <table>
      <thead>
        <tr>
          <th>ID</th>
          <th>Title</th>
          <th>Severity</th>
          <th>Category</th>
          <th>Status</th>
          <th>Discovered</th>
        </tr>
      </thead>
      <tbody>
        ${exploits
          .map(
            e => `
          <tr>
            <td><code>${e.id}</code></td>
            <td><strong>${e.title}</strong></td>
            <td><span class="severity-badge severity-${e.severity}">${e.severity}</span></td>
            <td>${e.category}</td>
            <td>${e.fixStatus}</td>
            <td>${e.discoveredAt.toLocaleDateString()}</td>
          </tr>
        `
          )
          .join('')}
      </tbody>
    </table>

    <div class="footer">
      <p>Total exploits: ${exploits.length} | Export format: HTML</p>
    </div>
  </div>
</body>
</html>
`;

    const filename = path.join(
      this.dataDir,
      `exploits-report-${new Date().toISOString().replace(/[:.]/g, '-')}.html`
    );

    fs.writeFileSync(filename, html);

    console.log(`[ExploitTracker] Exported HTML report: ${filename}`);
    return filename;
  }

  /**
   * Print summary to console
   */
  printSummary(): void {
    console.log(this.generateSummaryReport());
  }
}

// ============================================================================
// EXPORTS
// ============================================================================

export default ExploitTracker;
